模块：
用户管理：

用户登录：Login		=> 	/login 			=> login.LoginHandler
	请求：post
	参数：{
		username: 用户名,
		password: 密码
	}
	返回：{
		state: 状态值， {0: 异常，1: 成功，2: 失败},
		message: 返回消息
	}



用户注销： Logout	=>	/logout 		=>	logout.LogoutHandler
	请求： post
	参数： {
		username: username
	}
	返回：{
		state: 状态值，{0: 异常，1：成功，2：失败},
		message: 返回消息
	}

用户注册： Register	=>	/user 		=> user.UserHandler
	请求： post
	参数：{
		username: 用户名，
		password: 密码
	}
	返回：{
		state: 状态值，{0: 异常，1：成功，2：失败},
		message: 返回消息
	}

获取用户信息： getUserInfo	=>	/user_info	=>	user.UserHandler.user_info
	请求： get
	参数： {
		无，	通过session获取
	}
	返回：{
		username: 用户名
		nickname: 昵称
		logo: 用户头像
		type:　用户类型
	}

搜索用户： getUser		=>	/user 		=>	user.UserHandler
	请求： get
	参数：{
		username: 用户名, 	通过用户名，则是搜索用户信息
		user_id: 用户ID，  两者可选一，通过ID，则是点击用户头像获取的用户信息
	}
	返回：{
		state： 状态值，{0: 异常，1：成功，2：失败}， 
		data: {'id': 用户ID， 'username': 用户名, logo: 头像, 'nickname': 用户昵称}
	}
	逻辑：
	1. 获取用户名，用户ID
	2. 判断查询用户是否存在，并且是否拥有搜索权限，只有站长和副站长拥有搜索权限
	3. 若用户名存在，则返回单个用户，否则返回所有用户 


用户修改： updateUser	=>	/user 		=>	user.UserHandler
	请求： put
	参数： {
		logo: 用户头像
		password: 用户密码		// 判断old_password是否在数据中，若存在则为修改密码，否则为修改昵称
		nickname: 用户昵称
	}
	返回：{
		state： 状态值，{0: 异常，1：成功，2：失败}
	}
	执行逻辑：
	1. 判断用户是否存在
	2. 判断用户头像是否存在，若头像存在则为修改头像
	3. 获取用户昵称是否存在，若昵称存在则为修改昵称
	4. 判断密码，若存在则为修改密码

删除用户： deleteUser	=>	/user 		=>	user.UserHandler


/*----------------------------    群组操作   ---------------------------------*/
获取群组： getGroup 		=>		/group 		=>		group.GroupHandler
	请求： get
	参数： {
		group_id: 群组ID
	}
	返回: {
		code: 状态值,
		data: 群组列表
	}
	逻辑：
	1. 从session中获取用户ID，判断用户是否存在
	2. 判断group_id是否存在
	3. 若group_id存在，则只返回当前群组信息
	否则：
	1. 获取用户权限，若为站长，则返回所有群组信息
	2. 若为其它，则只返回包含该用户的群组

添加群组： addGroup		=>		/group  	=>  	group.GroupHandler
	请求： post
	参数： {
		user_id: 用户ID，	只有站长或管理员能创建群
		group_name: 群组名称， 
		logo: 群组头像，
	}
	返回： {
		state: 状态值，{0: 异常，1：成功，2：失败}
	}
	逻辑：
	1. 获取用户ID，判断用户是否存在，判断用户是否拥有建群权限
	2. 获取群组名称，判断群组名称是否存在
	3. 添加群，然后在群成员表中将此用户加入，类型设置为群主
	4. 随机选取一张图片做为群图片




修改群组信息： updateGroup	=>	/group 			=>		group.GroupHandler
	请求： put
	参数： {
		group_id: 要修改的群组ID，
		group_name: 群组名称，
		group_logo: 群组头像，
	}
	返回：{
		state: 状态值，{0: 异常，1：成功，2：失败}
	}
	逻辑：
	1. 获取要修改的群组ID，用户ID，群组名称和群组头像，并判断是否存在，名称和头像必须存在一个
	2. 判断群组是否存在，判断用户是否存在，并且判断用户是否拥有修改群组信息权限，只有管理员和群主和站长有权限
	3. 修改群组信息

删除群组信息： deleteGroup	=>	/grpup 		=>		group.GroupHandler
	请求： delete
	参数： {
		group_id: 要删除的群组ID
		user_id: 用户ID
	}
	返回：{
		state: 状态值，{0: 异常，1：成功，2：失败}
	}
	逻辑：		*****************
	1. 获取群组ID和用户ID，判断群组和用户是否存在
	2. 判断用户是什么权限
	3. 若是群主，则删除群，并删除群成员
	4. 若是管理员或用户，则在该群中删除成员



/*---------------------------------   群组成员操作   ---------------------------------*/
获取群成员列表： getGroupUser		=>	/group_user		=>		group_user.GroupUserHandler
	请求： get
	参数： {
		user_id: 用户ID
		group_id: 群组ID
	}
	返回： {
		state: 状态值，
		data_list: 成员列表，
		total: 条数
	}
	逻辑：
	1. 获取用户ID，群组ID，判断用户和群组是否存在
	2. 判断用户是否拥有获取群组信息权限，只有站长或者群成员拥有获取群成员权限
	3. 返回成员列表

群组添加成员： addGroupUser 		=>	/group_user		=>		group_user.GroupUserHandler
	请求： post
	参数：{
		group_id: 当前群组ID
		member_list: 添加成员
	}
	返回：{
		state: 状态值，{0: 异常，1：成功，2：失败}
	}
	逻辑：
	1. 获取群组ID，用户ID，成员列表，判断是否为空
	2. 获取群组对象，判断群组是否存在
	3. 获取用户对象，判断用户是否有添加成员权限，只有站长，群主，管理员有加人权限
	4. 添加成员

群组修改成员： updateGroupUser	=>	/group_user		=>		group_user.GroupUserHandler
	请求： put
	参数：{
		group_id: 当前群组ID，
		to_user_id: 要修改备注名的用户ID，
		group_type: 修改用户状态，[1, 2]	
	}
	返回：{
		state: 状态值，{0: 异常，1：成功，2：失败}
	}
	逻辑：
	1. 获取群组ID，用户ID，被修改用户ID，备注名称，判断是否为空
	2. 判断群组是否存在，用户是否存在
	3. 判断用户是否在群组中
	4. 判断用户是否拥有修改权限，除管理员，群主，站长外，本人只能修改本人的备注名

群组删除成员： deleteGroupUser 		=>	/group_user		=>		group_user.GroupUserHanler
	请求： delete
	参数：{
		group_id: 当前群组ID，
		member_list: 被删除成员ID
	}
	返回： {
		state: 状态值，{0: 异常，1：成功，2：失败}
	}
	逻辑：
	1. 获取群组，用户，被删除成员，判断是否为空
	2. 获取用户信息，判断用户是否为副站长或者群主或者群管理员，是否有T人权限，并且管理员不能踢除管理员，站长可以T
	3. 将成员从群组中删除


/*---------------------------------   好友列表操作   ---------------------------------*/

获取好友列表： getFriend 		=>	/friend 	=>	friend.FriendHandler
	请求： get
	参数：{
		无，通过session获取用户ID
	}
	返回：{
		state: 状态值， 
		data_list: 好友列表 
	}
	逻辑：
	1. 获取请求用户ID
	2. 从好友表中获取用户好友信息
	3. 返回状态和好友列表

添加好友:  addFriend		=>	/friend 	=>	friend.FriendHandler
	请求： post
	参数： {
		friend_id: 被添加的好友ID，
		group_id: 通过群添加好友，
	}
	返回： {
		state: 状态值
	}
	逻辑：
	1. 获取被添加好友ID
	2. 判断group_id是否存在，不存在，只有副站长拥有添加权限
	3. 若group_id存在，判断是否为管理员或者副站长，不然无权限
	4. 好友表做相互添加操作
	5. 返回状态值

更新好友信息: updateFriend	=>	/friend 	=>	friend.FriednHandler
	请求： put
	参数：{
		friend_id: 好友ID
		reamek: 备注名称
	}
	返回： {
		state: 状态值
	}
	逻辑：
	1. 获取好友ID和备注名称
	2. 判断好友是否存在，备注名称是否为空
	3. 修改好友备注名称，返回状态


删除好友： delFriend		=>	/friend 	=>	friend.FriendHandler
	请求： delete
	参数： {
		friend_id: 好友ID
	}
	返回：{
		state:　删除状态
	}
	逻辑：
	1. 获取好友ID
	2. 判断好友是否存在
	3. 删除好友信息

/*---------------------------------   聊天列表   ---------------------------------*/
Chat
id, user_id, name, type , logo, chat_obj_id
获取聊天列表： getChat	=>	/chat 		=>	chat.ChatHandler
	请求： get
	参数：{
		无
	}
	返回：{
		state: 状态，
		data_list: 聊天列表
	}
	逻辑：
	1. 从session中获取用户ID
	2. 判断用户是否存在
	3. 从chat表中获取用户的当前聊天窗口


添加聊天列表： addChat	=>	/chat 		=>	chat.ChatHandler
	请求： post
	参数： {
		user_id: 用户ID，
		type: 聊天类型,
		chat_obj_id: 聊天对象ID,
		logo: 聊天头像,
		name: 聊天名称,
	}
	返回： {
		code: 状态码
	}
	逻辑：
	1. 从session中获取用户ID
	2. 判断用户是否存在
	3. 判断聊天对象是否存在
	4. 若存在，返回聊天消息
	5. 若不存在，返回聊天消息为空

删除聊天列表： deleteChat		=>	/chat 	=>	chat.ChatHandler
	请求：delete
	参数： {
		chat_id: 当前聊天窗口的ID
	}
	返回：{
		state: 状态
	}
	逻辑：
	1. 获取用户传进来的聊天ID
	2. 根据session判断用户是否登录
	3. 删除当前聊天
	4. 前端列表中删除当前聊天


好友消息处理： getChatMessage		=>	/chat_message	=>	chat_message.ChatMessageHandler 
	ChatMessage
	chat_id: 聊天ID
	message: 消息内容
	add_time: 添加时间
	user_id: 发送的用户ID
	请求： get
	参数： {
		chat_id: 选中的聊天ID
	}
	返回： {
		state: 状态，
		data_list: 返回的消息列表
	}
	逻辑：	（不保存群组的聊天消息，因此只需要判断该用户和聊天对象ID是否属于好友关系）
	1. 获取用户传进来的聊天ID
	2. 判断当前聊天是否存在，判断当前用户是否属于该聊天，通过聊天ID获取聊天类型，再获取是群组聊天还是单用户聊天，若是群组，判断该用户是否在群组中，若是单用户，则判断用户是否有该好友
	3. 获取该聊天的消息

# 用户数据保存，与聊天ID对应，保存到缓存数据库中，周期为一周

发送消息设置：
1. 前端用户发送消息
	格式： {
		'chat_id': 聊天ID,
		'user_id': 用户ID,
		'message': 消息,
	}
	逻辑：
	1. 获取前端数据
	2. 根据聊天ID， 获取所有聊天用户对象
	3. 向聊天用户对象发送此条消息
	4. 将消息添加到缓存中， 可做成只有单聊添加


用户消息数据格式

message_data = {
	name: [{'name': '', 'logo': '', 'message': ''}]
}

聊天列表：[
	{
	id: '',
	name: '',
	logo: '',
	'type': '',
	'friend_list': [
		{
			'id': '',
			'name': '',
			'logo': '',
		}
	]
	}]

好友数据格式：{
	username: '',
	nickname: '',
	remark_name: '',
	logo: '',
	type: '',
}

需求：
1. 只有副站长可以建群，副站长即为群主
2. 副站长可以设置管理员，管理员只能添加本群成员
3. 副站长和管理员添加成员，不需要经过用户同意，直接添加
4. 普通用户没有添加好友权限


只有站长可以建群，站长可以设置用户为群管理员，管理员和站长可以踢人，设置群禁言。
站长可以解散群，站长和管理员拉人不需要好友同意，强制进群
群里面可以@人。
Duckchat的emoji加进来
可以改群名/群头像/群公告/退出群组
不需要语音视频和文件上传功能，可以发图片，文字
可以给好友备注，备注字符长度不限制
用户可以改昵称改头像，改登录密码
只有站长和群管理员可以加人（强制加人，不需要同意）&发起临时会话
显示群人数，显示群在线人数，后台记录登录用户IP和地区显示






手机网页版增加新功能，如下图，橙色箭头为按钮，点击按钮调出target广告网站，记录session，保持登录状态。站长后台可以自定义该广告网站地址。广告网站大小与聊天窗口大小一致。



web设计
1. 登录页面，根据页面大小响应式显示
2. 登录成功，转入聊天页面
3. 在mounted中获取用户信息，用户ID, 头像， 昵称， 类型信息
4. 显示用户只有聊天，好友，群聊，个人页面，没有上面的按钮
5. 上面按钮，可添加好友和创建群组
6. 在群聊页面，好友列表中，群管理员和站长可添加好友，不需要用户同意
7. 聊天页面，设计一个全屏的页面，有一个好友消息列表，将好友消息加入到列表中，聊天列表只显示最后一条消息记录，或者做成一个全新的页面，将用户ID和聊天ID传进去，来获得聊天信息
8. 针对聊天页面，设计一个聊天表，为当前用户的聊天对象表，聊天表记录用户聊天对象，和最后一条聊天信息
9. 全部放在一个页面，点击的时候切换效果


好友管理：
1. 显示当前好友信息
2. 一个修改按钮，一个删除按钮
3. 修改按钮弹出修改备注名称框，删除按钮弹出删除确认框

群组管理：
1. 显示当前群组信息
2. 管理员可以添加当前群成员为好友，不需要经过同意，可以踢人，改备注名
3. 站长可以提升管理员


全部放在同一个页面
1. 对单聊和群聊做不同处理
2. 单聊点击聊天时，出现聊天对话框，并获取当前聊天信息		

聊天页面
有一个聊天列表
chat_list = [
	{
		type: 聊天类型,
		id: 当前聊天的ID，
		name: 当前聊天的名称
		logo: 当前聊天的头像
		message:　当前聊天的最后一条消息
	}
]

message_data = {
	'chat1': [
		{
			'id': 好友ID, 
			'name': 好友名称,
			'logo': 好友头像,
			'message': 好友消息,
			'add_time':　消息发送时间,
		},
	]
		
	,
	'group1': [
		{

		}
	]
}

聊天页面对应一个聊天表Chat
id: 表ID
type: 聊天类型
logo: 聊天头像
name: 聊天名称，群组为群组名称，好友对应备注名称
chat_id: 聊天ID


添加好友
1. 搜索要添加的好友
2. 选择好友，点击添加
3. 显示添加完成或失败
4. 将好友加入到好友列表，每次重载好友页面，都请求好友信息（只有单聊才获取好友消息）

前端设计：
1. 好友页面点击进入另一个页面，提供好友删除，修改备注名称功能
2. 群组页面点击进入另一个页面，提供退出群组，管理员拥有修改群组名称和群组群公告功能和群头像功能，站长拥有解散群功能，并增加禁言功能
3. 群组页面，可添加删除群成员，只有管理员和站长拥有该权限



socket设计

前端发送消息场景

1. 单聊发送消息
2. 群聊发送消息
3. 添加好友发送消息
4. 入群消息提醒
5. 踢群消息提醒


添加页面：
1. 新建群组
	- 点击新建群组
	- 弹出页面输入群组名称
	- 点击提交
	- 返回群组是否创建成功
	- 创建成功，回到当前页面

	create_group_active: false,

2. 添加好友
	- 弹出好友搜索框
	- 输入好友名称
	- 搜索好友
	- 弹出好友头像框
	add_friend_active: false,


聊天通信逻辑：
1. 用户登录成功后，获取用户sid和用户ID绑定，保存到redis中，并且更改用户在数据库中的登录状态
2. 加入聊天室则将用户sid加入，以chat_sid_userid
3. 当用户在chat页面时，也需要将sid chat_list_sid_groupid 加入，将最新chat信息发送给用户






GO：
